%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CMPT 435
% Fall 2021
% Assignment One
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from: http://www.LaTeXTemplates.com
% Original author: % Frits Wenneker (http://www.howtotex.com)
% License: CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% Modified by Alan G. Labouseur  - alan@labouseur.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[letterpaper, 10pt,DIV=13]{scrartcl} 

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm,xfrac} % Math packages
\usepackage{sectsty} % Allows customizing section commands
\usepackage{graphicx}
\usepackage[lined,linesnumbered,commentsnumbered]{algorithm2e}
\usepackage{listings}
\usepackage{parskip}
\usepackage{lastpage}

\allsectionsfont{\normalfont\scshape} % Make all section titles in default font and small caps.

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{page \thepage\ of \pageref{LastPage}} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs.

\binoppenalty=3000
\relpenalty=3000

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
   \normalfont \normalsize 
   \textsc{CMPT 435 - Fall 2021 - Dr. Labouseur} \\[10pt] % Header stuff.
   \horrule{0.5pt} \\[0.25cm] 	% Top horizontal rule
   \huge Assignment One  \\     	    % Assignment title
   \horrule{0.5pt} \\[0.25cm] 	% Bottom horizontal rule
}

\author{Harrison Zheng \\ \normalsize harrison.zheng1@marist.edu}

\date{\normalsize\today} 	% Today's date.

\begin{document}
\maketitle % Print the title

%----------------------------------------------------------------------------------------
%   start PROBLEM ONE
%----------------------------------------------------------------------------------------

\section{Assignment Description}
For assignment 1, students were asked to develop a program that reads from a text file and determines whether each line is a palindrome. A palindrome is a word or phrase that reads the same forward and backward (ex: radar). Students were required to write and use a linked list, stack, and queue in their solution without built-in language features, like Java.Collections.Stack. Although I was not able to get my program to print out the palindromes, I was able to successfully create and manipulate these three data structures.

\horrule{0pt}  	% Bottom horizontal rule

\section{Main Program}
Execution of my program begins in the main method, which is held in a class named PalindromeChecker. The method first reads the content from a given text file,  MagicItems.txt, into an array. It then creates and populates a linked list, stack, and queue for each magic item (more details on these processes are provided in sections 3 - 5). The program uses class functions to create 2 arrays that hold the characters of magic items in the stack and queue. Finally, the main method calls on another method to compare the characters in the arrays, and if they all match, then the magic item is a palindrome and the program prints it out (Listing 2.1 Line 56-64). 

\horrule{0pt}  	% Bottom horizontal rule

\subsection{Main program source code listings}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ] 
public class PalindromeChecker {
    public static void main(String[] args) {
        System.out.println("The following magic items are palindromes: ");
        
        //Read file items into an array
        String[] arr = new String[666];
        try {
            File fileObj = new File("magicitems.txt");
            Scanner myReader = new Scanner(fileObj);
            for (int i = 0; i < arr.length; i++) {
                arr[i] = myReader.nextLine();
            }
            myReader.close();
        }
        catch (FileNotFoundException ex) {
            System.out.println("See error below.");
            ex.printStackTrace();
        }

        //Create a linked list, stack, and queue, and
        //determine if magic item is a palindrome
        for (int i = 0; i < arr.length; i++) {
            String magicItem = arr[i];

            //Sanitize the string
            magicItem = magicItem.replaceAll("\\s", "");
            magicItem = magicItem.replaceAll("[0-9+-,._()/\']", "");
            magicItem = magicItem.toLowerCase();

            //Create a LinkedList
            LinkedList listOfChars = LinkedList.createLinkedList(magicItem);

            //Initialize a stack and queue
            Stack stackOfChars = new Stack();
            Queue queueOfChars = new Queue();

            //For every node in linked list, push and enqueue it
            Node n = listOfChars.head;
            while (n != null) {
                stackOfChars = Stack.Push(stackOfChars, n);
                queueOfChars = Queue.Enqueue(queueOfChars, n);
                n = n.next;
            }

            //Remove nodes from the stack and queue and store their character values
            char[] stackArr = Stack.Pop(stackOfChars, magicItem.length());
            char[] queueArr = Queue.Dequeue(queueOfChars, magicItem.length());

            if (isPalindrome(stackArr, queueArr, magicItem.length())) {
                //Print the magic item if it passes the palindrome check
                System.out.println(magicItem);
            }
        }
    }

    //Checks if the magic item is a palindrome
    public static boolean isPalindrome(char[] stack, char[] queue, int strLength) {
        for (int i = 0; i < strLength; i++) {
            if (stack[i] != queue[i]) {
                return false;
            }
        }
        return true;
    }
}
\end{lstlisting}

\section{Node \&\ Linked List}\label{operations}
The Node class is used to create nodes, which are then used to create linked lists, queues, and stacks by other functions in the program. A Node object has attributes to store a particular character from a magic item and to point to the memory address of another node (Listing 3.1 Line 3-4). This makes nodes useful for all three data structures required by this assignment. The LinkedList class uses nodes by assigning characters to each one and then appending them to one another to represent a magic item. When appending nodes after the first one, the program iterates through the current linked list until it finds the last one and it adds a pointer to the new node there (Listing 3.2 Line 23-27).

\horrule{0pt}  	% Bottom horizontal rule

\subsection{Node class source code listings}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ] 
//Node class is used for creating elements in linked lists, stacks, and queues
public class Node {
	char character;
	Node next;

    //Constructor initializes properties of new Node instances
    public Node(char character) {
        this.character = character;
        this.next = null;
    }

}
\end{lstlisting}

\horrule{0pt}  	% Bottom horizontal rule

\subsection{LinkedList class source code listings}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ] 
//LinkedList class is used to create linked lists
public class LinkedList {
    Node head;

    //Constructor
    public LinkedList() {
        this.head = null;
    }

    //Makes linked list out of string passed in
    public static LinkedList createLinkedList(String magicItem) {
        LinkedList listOfChars = new LinkedList();
        for (int j = 0; j < magicItem.length(); j++) {
            Node character = new Node(magicItem.charAt(j));

            //Set the first char node as the list's head
            if (j == 0) {
                listOfChars.head = character;
            }
            //For rest of chars, go to last node in list 
            //and add new char node to its next pointer
            else {
                Node tail = listOfChars.head;
                while (tail.next != null) {
                    tail = tail.next;
                }
                tail.next = character;
            }
        }
        return listOfChars;
    }

}
\end{lstlisting}

\horrule{0pt}  	% Bottom horizontal rule

\section{Stack}\label{operations}
My program uses the Stack class to create stacks and perform operations on them. It has a method named Push, which adds the old node currently at the top of the stack to a new node's next pointer and makes the new node the top (Listing 4.1 Line 10-15). It has a Pop method, which moves the stack's top pointer to the node below the one currently on top so that the old top node is effectively removed from the stack. It then stores the popped node in an array that is used by the main program, and it repeats this process until every node has been popped from the stack (Listing 4.1 Line 17-36). The class also has a method named isEmpty, which checks if the stack is empty and it is used by the Pop method (Listing 4.1 Line 38-46).

\horrule{0pt}  	% Bottom horizontal rule

\subsection{Stack class source code listings}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ] 
//Stack class is used to create and perform operations on stacks
public class Stack {
    Node top;

    //Constructor
    public Stack() {
        this.top = null;
    }
    
    //Adds a node at the top of a stack
    public static Stack Push(Stack stackOfChars, Node newNode) {
        newNode.next = stackOfChars.top;
        stackOfChars.top = newNode;
        return stackOfChars;
    }
    
    //Pops every node in a stack and puts them into an array
    public static char[] Pop(Stack stackOfChars, int strLength) {
        char[] stackArr = new char[strLength];
        int stackCounter = 0;
        Node s = stackOfChars.top;
        while (s != null) {
            Node topNode = s;
            if (!Stack.isEmpty(stackOfChars)) {
                //Change top pointer to point to the node below the one currently on top 
                stackOfChars.top = stackOfChars.top.next;
            } else {
                //Handle an underflow error
                System.out.println("Warning! Cannot pop an empty stack!");
            }
            stackArr[stackCounter] = topNode.character;
            stackCounter += 1;
            s = s.next;
        }
        return stackArr;
    }

    //Checks whether a stack is empty
    public static boolean isEmpty(Stack stackOfChars) {
        if (stackOfChars.top == null) {
            return true;
        }
        else {
            return false;
        }
    }

}
\end{lstlisting}

\horrule{0pt}  	% Bottom horizontal rule

\section{Queue}\label{operations}
My program uses the Queue class to create queues and perform operations on them. It is important to note that unlike linked lists and stack, queues have 2 pointers; one at the head and one at the tail. The class has a method named Enqueue, which adds the pointer to a new node to the node currently at the end of the queue so that the new node becomes the tail (Listing 5.1 Line 12-23). It has a Dequeue method, which moves the queue's head pointer to the next node down. Like the Stack class's Pop method, Dequeue stores the dequeued node in an array that is used by the main program, and it repeats this process until every node has been dequeued from the queue (Listing 5.1 Line 25-48). The class also has a method named isEmpty to check if the queue is empty, and it is used by the Enqueue and Dequeue methods (Listing 5.1 Line 50-59).

\subsection{Queue class source code listings}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt, basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[frame=single, ] 
//Queue class is used to create and perform operations on queues
public class Queue {
    Node head; 
    Node tail;

    //Constructor
    public Queue() {
        this.head = null;
        this.tail = null;
    }

    //Adds a node to the end of a queue
    public static Queue Enqueue(Queue queueOfChars, Node newNode) {
        if (isEmpty(queueOfChars)) {
            queueOfChars.head = newNode;
            queueOfChars.tail = newNode;
        }
        else {
            queueOfChars.tail.next = newNode;
            queueOfChars.tail = newNode;
        }
        return queueOfChars;
    }
    
    //Dequeues every node in the queue and puts them into an array
    public static char[] Dequeue(Queue queueOfChars, int strLength) {
        char[] queueArr = new char[strLength];
        int queueCounter = 0;
        Node q = queueOfChars.head;
        while (q != null) {
            Node headNode = q;
            if (!Queue.isEmpty(queueOfChars)) {
                //Change head pointer to point to the next node
                queueOfChars.head = queueOfChars.head.next;
                if (Queue.isEmpty(queueOfChars)) {
                    queueOfChars.tail = null;
                }
            } 
            else {
                //Handle an underflow error
                System.out.println("Warning! Cannot dequeue an empty queue!");
            }
            queueArr[queueCounter] = headNode.character;
            queueCounter += 1;
            q = q.next;
        }
        return queueArr;
    }

    //Checks whether a queue is empty
    public static boolean isEmpty(Queue queueOfChars) {
        if (queueOfChars.head == null) {
            return true;
        }
        else {
            return false;
        }
    }
}
\end{lstlisting}

\end{document}
